package RSA;

import GroupOfUnits.groupOfUnits;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Random;

public class FullRSA {
	public static void main(String[] args) throws IOException {
		FullRSA fr = new FullRSA();
		groupOfUnits gou = new groupOfUnits();
		//BigInteger p = randomPrime(300);
		//BigInteger p = probablePrime((int)(300*3.2)+1,new Random());
		//BigInteger q = randomPrime(300);
		BigInteger p = new BigInteger("3362327510949069277068784884690918449394539504808263321788430077271677416931013117369850269412222256384749071065459306702751619930023594674393016835264405631481906230323611361394143348296585061174935105765653584098580467800741631535708893553561022682073748350336883374620504601626861443840177540197751");
		BigInteger q = new BigInteger("281333344708466996369222542624189842205042006818321754789752441165074558579896197113794968264053774765459740024062484640941468064588529738912956332676988612044265834581230173365857230794208116776031207537198467051593714547703844957235121014710878472594892451536753038441077793343874062281175054427453");
		while (!fr.checkProduct(p, q)) {
			p = randomInteger(300).nextProbablePrime();
			q = randomInteger(300).nextProbablePrime();
		}
		BigInteger n = p.multiply(q);
		BigInteger phi_n = p.subtract(BigInteger.ONE).multiply(
				q.subtract(BigInteger.ONE));
		// public key
		BigInteger e = new BigInteger("65537");
		// private key
		BigInteger d = inverse(e, phi_n);
		FileToString fs = new FileToString("src/cs-description.txt");
		// System.out.println(fs.fileString);
		ArrayList<String> blocks = fr.toStringBlocks(fs.fileString);
		ArrayList<BigInteger> plaintext = fr.toBigIntBlocks(blocks);
		//ArrayList<BigInteger> encrypted = fr.encrypt(plaintext, e, n);
		ArrayList<BigInteger> encrypted = new ArrayList<BigInteger>();
		encrypted.add(new BigInteger("27615887459063843766779648204866194360687419289615975357345892098007272739715188584518943137128028481318710741686908923385248853867093255126670441155741068182555965642686516146309952192824451262817201106628679596315102228315882472016674068431345971047565251048236257374375879665554055482114367723735568118346448005673049303772885008572241891155684323709782005071240841629701178581172006114412576213423466635072805992444806632256673278788617068111282162338093494381296978761931359260533782205311156118820956309988735378852535328835310197037903333632884471871880556053541870202385817726048221692467620"));
		encrypted.add(new BigInteger(""));
		ArrayList<BigInteger> decrypted = fr.decrypt(encrypted, d, n);
		ArrayList<String> backToStringBlocks = fr
				.plainTextToStringBlocks(decrypted);
		fr.writeToFile(backToStringBlocks,"src/output.txt");
		
		for (BigInteger b : plaintext) {
			System.out.println(b.toString());
		}
		System.out.println("Middle");
		for (BigInteger b : decrypted) {
			// System.out.println(b.toString());
		}
		for (String s : backToStringBlocks) {
			System.out.println(s);
		}
	}

	public void writeToFile(ArrayList<String> decrypted, String targetFilePath) throws IOException
	{
		String text = "";
	    Path targetPath = Paths.get(targetFilePath);
	    for(String s : decrypted){
	    	text+=s;
	    }
	    byte[] bytes = text.getBytes(StandardCharsets.UTF_8);
	    Files.write(targetPath, bytes, StandardOpenOption.CREATE);
	}

	public ArrayList<String> plainTextToStringBlocks(ArrayList<BigInteger> input) {
		ArrayList<String> result = new ArrayList<String>();
		int increment = 3;
		for (BigInteger b : input) {
			BigInteger temp = b;
			String output = "";
			while (increment <= temp.toString().length()) {
				BigInteger segment = b.mod(BigInteger.valueOf(10)
						.pow(increment));
				int digits = Integer.parseInt(segment.toString()
						.substring(0, 3));
				b = b.subtract(segment);
				char c = unPaddedAscii(digits);
				output = c + output;
				increment += 3;
			}
			result.add(output);
			increment = 3;
		}
		return result;
	}

	public char unPaddedAscii(int i) {
		int unpadded = i - 100;
		return (char) unpadded;
	}

	public ArrayList<BigInteger> decrypt(ArrayList<BigInteger> encrypted,
			BigInteger d, BigInteger n) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (BigInteger i : encrypted) {
			result.add(i.modPow(d, n));
		}
		return result;
	}

	public ArrayList<BigInteger> encrypt(ArrayList<BigInteger> input,
			BigInteger e, BigInteger n) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (BigInteger i : input) {
			result.add(i.modPow(e, n));
		}
		return result;
	}

	public ArrayList<String> toStringBlocks(String input) {
		ArrayList<String> blocks = new ArrayList<String>();
		char[] chars = input.toCharArray();
		int index = 0;
		int upperlimit = 0;
		String stringToAdd = "";
		while (index < input.length()) {
			upperlimit = input.length() - index < 200 ? input.length() - index
					: 200;
			stringToAdd = input.substring(index, index + upperlimit);
			if (upperlimit < 200)
				stringToAdd = stringToAdd
						+ String.format("%" + (200 - upperlimit) + "s", "")
								.replace(" ", String.valueOf(' '));
			blocks.add(stringToAdd);
			index += upperlimit;
		}
		return blocks;
	}

	public String toPaddedAscii(char c) {
		Integer padded = (int) c + 100;
		return padded.toString();
	}

	public ArrayList<BigInteger> toBigIntBlocks(ArrayList<String> input) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (String s : input) {
			String bigInt = "";
			char[] chars = s.toCharArray();
			for (char c : chars) {
				bigInt += toPaddedAscii(c);
			}
			result.add(new BigInteger(bigInt));
		}
		return result;
	}

	public boolean checkProduct(BigInteger p, BigInteger q) {
		BigInteger product = p.multiply(q);
		return product.toString().length() >= 600
				&& Integer.parseInt(product.toString().substring(0, 6)) > 355355;
	}

	// Return random
	public static BigInteger randomInteger(int ndigits) {
		Random rand = new Random();
		int len = (int) (3.32 * (double) ndigits); // log(10)/log(2) = 3.32
		return new BigInteger(len, rand);
	}

	// Return random prime approx. ngidits in length
	public static BigInteger randomPrime(int ndigits) {
		BigInteger p = randomInteger(ndigits);
		return p.nextProbablePrime();
	}

	public static BigInteger multiply(BigInteger a, BigInteger b) {
		return a.multiply(b);
	}

	public static BigInteger gcd(BigInteger a, BigInteger b) {
		return a.gcd(b);
	}

	public static BigInteger inverse(BigInteger a, BigInteger m) {
		return a.modInverse(m);
	}

	public static BigInteger modexp(BigInteger a, BigInteger b, BigInteger m) {
		return a.modPow(b, m);
	}

	public BigInteger getRabinMillerPrime(int ndigits) {
		Random rand = new Random();
		int len = (int) (3.32 * (double) ndigits); // log(10)/log(2) = 3.32
		BigInteger n = new BigInteger(len, rand);
		BigInteger a;
		// this.n = new BigInteger("750");
		BigInteger two = new BigInteger("2");
		// we know if it is even that it's not prime. we want prime
		if (n.getLowestSetBit() != 0)
			n = n.add(BigInteger.ONE);

		while (!two.modPow(n.subtract(BigInteger.ONE), n)
				.equals(BigInteger.ONE)) {
			n = n.add(two);
		}
		int counter = 0;

		while (counter < 100) {
			a = randomInteger(1024);
			while (a.compareTo(n) >= 0) {
				a = randomInteger(1024);
			}
			if (gcd(a, n).equals(BigInteger.ONE)) {
				counter++;
			} else {
				System.out.println(counter);
				break;
			}
		}
		if (counter != 100) {
			getRabinMillerPrime(ndigits);
		} else {
			return n;
		}
		return n;

	}
}
