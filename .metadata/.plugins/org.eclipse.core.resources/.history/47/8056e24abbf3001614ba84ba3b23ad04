package RSA;

import GroupOfUnits.groupOfUnits;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Random;

public class FullRSA {
	public static void main(String[] args) throws IOException {
		FullRSA fr = new FullRSA();
		groupOfUnits gou = new groupOfUnits();
		//BigInteger p = randomPrime(300);
		//BigInteger p = probablePrime((int)(300*3.2)+1,new Random());
		//BigInteger q = randomPrime(300);
		BigInteger p = new BigInteger("3362327510949069277068784884690918449394539504808263321788430077271677416931013117369850269412222256384749071065459306702751619930023594674393016835264405631481906230323611361394143348296585061174935105765653584098580467800741631535708893553561022682073748350336883374620504601626861443840177540197751");
		BigInteger q = new BigInteger("281333344708466996369222542624189842205042006818321754789752441165074558579896197113794968264053774765459740024062484640941468064588529738912956332676988612044265834581230173365857230794208116776031207537198467051593714547703844957235121014710878472594892451536753038441077793343874062281175054427453");
		while (!fr.checkProduct(p, q)) {
			p = randomInteger(300).nextProbablePrime();
			q = randomInteger(300).nextProbablePrime();
		}
		BigInteger n = p.multiply(q);
		BigInteger phi_n = p.subtract(BigInteger.ONE).multiply(
				q.subtract(BigInteger.ONE));
		// public key
		BigInteger e = new BigInteger("65537");
		// private key
		BigInteger d = inverse(e, phi_n);
		System.out.println(d.toString());
		FileToString fs = new FileToString("src/cs-description.txt");
		// System.out.println(fs.fileString);
		ArrayList<String> blocks = fr.toStringBlocks(fs.fileString);
		ArrayList<BigInteger> plaintext = fr.toBigIntBlocks(blocks);
		//ArrayList<BigInteger> encrypted = fr.encrypt(plaintext, e, n);
		ArrayList<BigInteger> encrypted = new ArrayList<BigInteger>();
		encrypted.add(new BigInteger("27615887459063843766779648204866194360687419289615975357345892098007272739715188584518943137128028481318710741686908923385248853867093255126670441155741068182555965642686516146309952192824451262817201106628679596315102228315882472016674068431345971047565251048236257374375879665554055482114367723735568118346448005673049303772885008572241891155684323709782005071240841629701178581172006114412576213423466635072805992444806632256673278788617068111282162338093494381296978761931359260533782205311156118820956309988735378852535328835310197037903333632884471871880556053541870202385817726048221692467620"));
		encrypted.add(new BigInteger("255661881920072174726578482991352507844096225644329825498031074895973268274114692310795014928407111661320119185225147778982844063252254492859809201860541244290407188994963902098592871923234259967732990087493926966986431360052399594239287102438007715873023665148920113651173824099053643940236141096934511624963348953310857855154282714224812706204667662011062808769938347507606083052937030990156738689414693195096354562592904972377693715743557639720642249948094029427990103132177368258342229496743536746851651186278184131996965824861934114208718079289472529773688633084908627606247953761950847588195691"));
		encrypted.add(new BigInteger("181824504018722945017709380576929876306656806963207251891929589795229949853444132213864190625253276125454247740064208824981369688585492829000151028914711130596557122284841730459198834464324979842668668595892688291447427552407105205761478555126426202273373337980246873722190650345961598990112289385467982483819070733185950736808985930364144843755846431204497020631931694799147061030216394589385131939210396027507674249681316424115890348788001021215853302701485671289124211924091062018758595890845955828554675176558697989150373263153439321256124839955622387451546831113891718607118535875164632948157490"));
		encrypted.add(new BigInteger("736083252042765376387046372362416018099372889817255372760981126089312009993014479365401592491177259926988622161705869209702468158698112983089843318918318754798208501859821003521643884553597181274279533366851246097312082683632672280546265541857649824731626524108861766863775871348861920974444176554043776435119010348269575584546343729093101512776944220167622593221714270099869573900068529270817212759967098234815269736695730568173332288320264166330488959984097335062677880923578350261215079699472514234659726392076500256899729701983194489874064531951725743984141015963475795044888871611854978738508257"));
		ArrayList<BigInteger> decrypted = fr.decrypt(encrypted, d, n);
		ArrayList<String> backToStringBlocks = fr
				.plainTextToStringBlocks(decrypted);
		fr.writeToFile(backToStringBlocks,"src/output.txt");
		
		for (BigInteger b : plaintext) {
			System.out.println(b.toString());
		}
		System.out.println("Middle");
		for (BigInteger b : decrypted) {
			// System.out.println(b.toString());
		}
		for (String s : backToStringBlocks) {
			System.out.println(s);
		}
	}

	public void writeToFile(ArrayList<String> decrypted, String targetFilePath) throws IOException
	{
		String text = "";
	    Path targetPath = Paths.get(targetFilePath);
	    for(String s : decrypted){
	    	text+=s;
	    }
	    byte[] bytes = text.getBytes(StandardCharsets.UTF_8);
	    Files.write(targetPath, bytes, StandardOpenOption.CREATE);
	}

	public ArrayList<String> plainTextToStringBlocks(ArrayList<BigInteger> input) {
		ArrayList<String> result = new ArrayList<String>();
		int increment = 3;
		for (BigInteger b : input) {
			BigInteger temp = b;
			String output = "";
			while (increment <= temp.toString().length()) {
				BigInteger segment = b.mod(BigInteger.valueOf(10)
						.pow(increment));
				int digits = Integer.parseInt(segment.toString()
						.substring(0, 3));
				b = b.subtract(segment);
				char c = unPaddedAscii(digits);
				output = c + output;
				increment += 3;
			}
			result.add(output);
			increment = 3;
		}
		return result;
	}

	public char unPaddedAscii(int i) {
		int unpadded = i - 100;
		return (char) unpadded;
	}

	public ArrayList<BigInteger> decrypt(ArrayList<BigInteger> encrypted,
			BigInteger d, BigInteger n) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (BigInteger i : encrypted) {
			result.add(i.modPow(d, n));
		}
		return result;
	}

	public ArrayList<BigInteger> encrypt(ArrayList<BigInteger> input,
			BigInteger e, BigInteger n) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (BigInteger i : input) {
			result.add(i.modPow(e, n));
		}
		return result;
	}

	public ArrayList<String> toStringBlocks(String input) {
		ArrayList<String> blocks = new ArrayList<String>();
		char[] chars = input.toCharArray();
		int index = 0;
		int upperlimit = 0;
		String stringToAdd = "";
		while (index < input.length()) {
			upperlimit = input.length() - index < 200 ? input.length() - index
					: 200;
			stringToAdd = input.substring(index, index + upperlimit);
			if (upperlimit < 200)
				stringToAdd = stringToAdd
						+ String.format("%" + (200 - upperlimit) + "s", "")
								.replace(" ", String.valueOf(' '));
			blocks.add(stringToAdd);
			index += upperlimit;
		}
		return blocks;
	}

	public String toPaddedAscii(char c) {
		Integer padded = (int) c + 100;
		return padded.toString();
	}

	public ArrayList<BigInteger> toBigIntBlocks(ArrayList<String> input) {
		ArrayList<BigInteger> result = new ArrayList<BigInteger>();
		for (String s : input) {
			String bigInt = "";
			char[] chars = s.toCharArray();
			for (char c : chars) {
				bigInt += toPaddedAscii(c);
			}
			result.add(new BigInteger(bigInt));
		}
		return result;
	}

	public boolean checkProduct(BigInteger p, BigInteger q) {
		BigInteger product = p.multiply(q);
		return product.toString().length() >= 600
				&& Integer.parseInt(product.toString().substring(0, 6)) > 355355;
	}

	// Return random
	public static BigInteger randomInteger(int ndigits) {
		Random rand = new Random();
		int len = (int) (3.32 * (double) ndigits); // log(10)/log(2) = 3.32
		return new BigInteger(len, rand);
	}

	// Return random prime approx. ngidits in length
	public static BigInteger randomPrime(int ndigits) {
		BigInteger p = randomInteger(ndigits);
		return p.nextProbablePrime();
	}

	public static BigInteger multiply(BigInteger a, BigInteger b) {
		return a.multiply(b);
	}

	public static BigInteger gcd(BigInteger a, BigInteger b) {
		return a.gcd(b);
	}

	public static BigInteger inverse(BigInteger a, BigInteger m) {
		return a.modInverse(m);
	}

	public static BigInteger modexp(BigInteger a, BigInteger b, BigInteger m) {
		return a.modPow(b, m);
	}

	public BigInteger getRabinMillerPrime(int ndigits) {
		Random rand = new Random();
		int len = (int) (3.32 * (double) ndigits); // log(10)/log(2) = 3.32
		BigInteger n = new BigInteger(len, rand);
		BigInteger a;
		// this.n = new BigInteger("750");
		BigInteger two = new BigInteger("2");
		// we know if it is even that it's not prime. we want prime
		if (n.getLowestSetBit() != 0)
			n = n.add(BigInteger.ONE);

		while (!two.modPow(n.subtract(BigInteger.ONE), n)
				.equals(BigInteger.ONE)) {
			n = n.add(two);
		}
		int counter = 0;

		while (counter < 100) {
			a = randomInteger(1024);
			while (a.compareTo(n) >= 0) {
				a = randomInteger(1024);
			}
			if (gcd(a, n).equals(BigInteger.ONE)) {
				counter++;
			} else {
				System.out.println(counter);
				break;
			}
		}
		if (counter != 100) {
			getRabinMillerPrime(ndigits);
		} else {
			return n;
		}
		return n;

	}
}
